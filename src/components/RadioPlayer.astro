---
// Use same-origin proxy para reproducir sin CORS
const STREAM_URL = "/api/stream";
// API interna para el cliente; para SSR usa endpoint absoluto
const STATUS_URL = "/api/getCurrentSong";
const DIRECT_STATUS_URL = "https://stream.noisk8.xyz/status-json.xsl";

interface StreamInfo { title?: string; artist?: string; }

let current: StreamInfo = {
  title: "",
  artist: "",
};

try {
  // En SSR, evita rutas relativas y consulta directamente el JSON de Icecast
  const response = await fetch(DIRECT_STATUS_URL, { cache: 'no-store', headers: { accept: 'application/json' } });
  if (response.ok) {
    const ct = response.headers.get('content-type') || '';
    if (!ct.includes('application/json')) throw new Error('Non-JSON response');
    const data = await response.json();
    const source = Array.isArray(data?.icestats?.source)
      ? data.icestats.source[0]
      : data?.icestats?.source;
    if (source) {
      current = {
        title: source.title || current.title,
        artist: source.artist || current.artist,
      };
    }
  }
} catch (error) {
  console.error("No se pudo obtener el título inicial del stream", error);
}
---

<section class="radio-shell">
  <div class="radio-content">
    <div class="radio-corners" aria-hidden="true">
      <span class="corner corner--tl"></span>
      <span class="corner corner--tr"></span>
      <span class="corner corner--bl"></span>
      <span class="corner corner--br"></span>
    </div>
    <header class="radio-headline">
      <div class="eq-badge" aria-hidden="true">
        <span class="eq-bar" style="animation-delay: 0ms"></span>
        <span class="eq-bar" style="animation-delay: 120ms"></span>
        <span class="eq-bar" style="animation-delay: 240ms"></span>
        <span class="eq-bar" style="animation-delay: 360ms"></span>
        <span class="eq-bar" style="animation-delay: 480ms"></span>
      </div>
      <!-- Títulos movidos debajo del reproductor -->
    </header>


      <audio
        id="radio-player"
        class="w-full bg-transparent px-6 pb-6 pt-12"
        preload="none"
        crossorigin="anonymous"
      >
        {import.meta.env.PROD ? (
          <source src="https://stream.noisk8.xyz/kbalahradio.ogg" type="audio/mpeg" />
        ) : (
          <>
            <source src={STREAM_URL} type="audio/mpeg" />
            <source src="https://stream.noisk8.xyz/kbalahradio.ogg" type="audio/mpeg" />
          </>
        )}
      </audio>
    

    <div class="player-foot">
      <div class="timeline-row">
        <span id="player-elapsed" class="time-chip">00:00</span>
        <div class="timeline-track">
          <div class="progress-track">
            <div id="player-progress-fill" class="progress-fill"></div>
          </div>
          <input
            id="player-progress"
            type="range"
            min="0"
            value="0"
            step="1"
            class="progress-range"
            aria-label="Avance de la pista"
          />
        </div>
        <span id="player-remaining" class="time-chip live-indicator">Fuera de aire</span>
      </div>

      <!-- Now playing, pequeño, una sola línea, entre timeline y botones -->
      <div class="nowplaying" aria-live="polite">
        <div class="title-line">
          <span class="np-dot" aria-hidden="true"></span>
          <span class="np-text">
            <span id="song-title">{current.title}</span>
      
            <span id="artist-name">{current.artist}</span>
          </span>
        </div>
      </div>

      <div class="action-row">
        <button
          id="player-toggle"
          class="player-control is-offline"
          type="button"
          aria-label="Reproducir"
        >
          <span class="player-symbol">
            <span class="player-icon" aria-hidden="true"></span>
          </span>
          <span class="player-label">Play</span>
        </button>

        <div class="volume-block">
          <span class="volume-kicker">Volumen</span>
          <div class="volume-control">
            <span class="fa-solid fa-volume-low" aria-hidden="true"></span>
            <input
              id="player-volume"
              type="range"
              min="0"
              max="1"
              step="0.05"
              value="0.8"
              class="volume-range"
              aria-label="Volumen"
            />
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<client:load>
  <script type="module">
    // Client-side URLs
    const STATUS_URL = "/api/getCurrentSong";
    const FALLBACK_STATUS_URL = "https://stream.noisk8.xyz/status-json.xsl";
    const STREAM_URL = "/api/stream";
    const player = document.getElementById("radio-player");
    const titleEl = document.getElementById("song-title");
    const artistEl = document.getElementById("artist-name");
    const toggleButton = document.getElementById("player-toggle");
    const progressInput = document.getElementById("player-progress");
    const progressFill = document.getElementById("player-progress-fill");
    const elapsedLabel = document.getElementById("player-elapsed");
    const remainingLabel = document.getElementById("player-remaining");
    const volumeInput = document.getElementById("player-volume");
    const labelSpan = toggleButton?.querySelector(".player-label");
    const panelContainer = document.querySelector(".radio-content");
    const LIVE_INDICATOR_TEXT = "EN VIVO";
    const OFFLINE_INDICATOR_TEXT = "Fuera de aire";

    const formatTime = (secs) => {
      if (!Number.isFinite(secs) || secs < 0) return "";
      const total = Math.floor(secs);
      const hours = Math.floor(total / 3600);
      const minutes = Math.floor((total % 3600) / 60)
        .toString()
        .padStart(2, "0");
      const seconds = Math.floor(total % 60)
        .toString()
        .padStart(2, "0");
      if (hours > 0) {
        return `${hours.toString().padStart(2, "0")}:${minutes}:${seconds}`;
      }
      return `${minutes}:${seconds}`;
    };

    let isPlaybackLive = false;
    let streamAvailable = false;

    const togglePlayer = () => {
      if (!player) return;
      if (player.paused) {
        player.play().catch((error) => {
          console.error("No fue posible iniciar el stream", error);
        });
      } else {
        player.pause();
      }
    };

    const updateLiveBadge = (state) => {
      if (!remainingLabel) return;
      if (state === "live") {
        const promptPlay = streamAvailable && !isPlaybackLive && player?.paused;
        remainingLabel.textContent = promptPlay
          ? `${LIVE_INDICATOR_TEXT} · Presiona Play`
          : LIVE_INDICATOR_TEXT;
        remainingLabel.classList.add("live-active");
        remainingLabel.classList.remove("live-offline");
      } else if (state === "offline") {
        remainingLabel.textContent = OFFLINE_INDICATOR_TEXT;
        remainingLabel.classList.remove("live-active");
        remainingLabel.classList.add("live-offline");
      }
    };

    const setLiveState = (isLive) => {
      streamAvailable = isLive;
      if (!toggleButton) return;
      toggleButton.dataset.live = isLive ? "on" : "off";
      toggleButton.classList.toggle("is-live", isLive);
      toggleButton.classList.toggle("is-offline", !isLive);
      panelContainer?.classList.toggle("is-live", isLive);
      if (!isPlaybackLive) {
        updateLiveBadge(isLive ? "live" : "offline");
      }
      updateToggleLabel();
    };

    const updateDurationState = () => {
      if (!player) return;
      const { duration } = player;
      const durationIsFinite = Number.isFinite(duration) && duration > 0;
      const durationIsUnknown = Number.isNaN(duration);
      const live = !durationIsUnknown && !Number.isFinite(duration);
      const offline = durationIsUnknown || duration <= 0;

      isPlaybackLive = live && !player?.paused;

      if (progressInput) {
        const disableProgress = live || offline || !durationIsFinite;
        progressInput.disabled = disableProgress;
        progressInput.classList.toggle("is-disabled", disableProgress);
        if (!disableProgress && durationIsFinite) {
          progressInput.max = Math.floor(duration).toString();
        }
      }

      if (remainingLabel) {
        if (live || streamAvailable) {
          updateLiveBadge("live");
        } else if (offline) {
          updateLiveBadge("offline");
        } else {
          remainingLabel.textContent = formatTime(duration);
          remainingLabel.classList.remove("live-active");
          remainingLabel.classList.remove("live-offline");
        }
      }
    };

    const updateProgressUI = (fromSlider = false) => {
      if (!player) return;
      const current = fromSlider && progressInput ? Number(progressInput.value) : player.currentTime;

      if (elapsedLabel) {
        elapsedLabel.textContent = formatTime(current);
      }

      if (isPlaybackLive) {
        updateLiveBadge("live");
        if (progressFill) {
          const fraction = (player.currentTime % 8) / 8;
          progressFill.style.transform = `scaleX(${0.2 + fraction * 0.8})`;
        }
        return;
      }

      const duration = Number.isFinite(player.duration) && player.duration > 0 ? player.duration : null;
      if (duration === null) {
        if (progressFill) {
          progressFill.style.transform = "scaleX(0)";
        }
        if (progressInput && !fromSlider) {
          progressInput.value = "0";
        }
        updateLiveBadge(streamAvailable ? "live" : "offline");
        return;
      }

      const percent = Math.min(current / duration, 1);
      if (progressFill) {
        progressFill.style.transform = `scaleX(${percent})`;
      }
      if (progressInput && !fromSlider) {
        progressInput.value = current.toString();
      }
      if (remainingLabel) {
        const remaining = Math.max(duration - current, 0);
        remainingLabel.textContent = formatTime(remaining);
        remainingLabel.classList.remove("live-active");
        remainingLabel.classList.remove("live-offline");
      }
    };

    const updateToggleLabel = () => {
      if (!toggleButton || !player) return;
      const isPaused = player.paused;
      const actionLabel = isPaused
        ? `Reproducir${streamAvailable ? " transmisión en vivo" : ""}`
        : "Detener transmisión";
      toggleButton.setAttribute("aria-label", actionLabel);
      toggleButton.classList.toggle("is-playing", !isPaused);
      if (labelSpan) {
        if (isPaused) {
          labelSpan.textContent = streamAvailable ? "Play En Vivo" : "Play";
        } else {
          labelSpan.textContent = "Stop";
        }
      }
      updateProgressUI();
    };

    toggleButton?.addEventListener("click", () => {
      togglePlayer();
      setTimeout(updateToggleLabel, 50);
    });

    player?.addEventListener("play", () => {
      updateToggleLabel();
      updateDurationState();
      updateProgressUI();
    });
    player?.addEventListener("pause", () => {
      updateToggleLabel();
      updateDurationState();
      updateProgressUI();
    });

    player?.addEventListener("waiting", () => {});
    player?.addEventListener("loadstart", () => {
      updateDurationState();
    });
    player?.addEventListener("playing", () => {
      setLiveState(true);
      updateDurationState();
      updateProgressUI();
    });
    player?.addEventListener("canplay", () => {
      updateDurationState();
    });

    player?.addEventListener("error", () => {
      setLiveState(false);
      isPlaybackLive = false;
      if (progressFill) {
        progressFill.style.transform = "scaleX(0)";
      }
      if (progressInput) {
        progressInput.value = "0";
      }
      updateLiveBadge("offline");
    });

    let currentTitle = titleEl?.textContent ?? "";
    let currentArtist = artistEl?.textContent ?? "";

    const pickSource = (payload) => {
      if (payload?.icestats?.source) {
        return Array.isArray(payload.icestats.source)
          ? payload.icestats.source[0]
          : payload.icestats.source;
      }
      return undefined;
    };

    async function fetchStatus() {
      try {
        const r = await fetch(STATUS_URL, { cache: "no-store" });
        if (r.ok) {
          const j = await r.json();
          if (j && (j.title || j.artist || j.online !== undefined)) return j;
        }
      } catch {}
      // Fallback a Icecast directo
      try {
        const r2 = await fetch(FALLBACK_STATUS_URL, { cache: "no-store" });
        if (r2.ok) {
          const j2 = await r2.json();
          const s = pickSource(j2);
          if (s) {
            return { title: s.title || "", artist: s.artist || "", online: true };
          }
        }
      } catch {}
      return { title: "", artist: "", online: false };
    }

    async function refreshNowPlaying() {
      try {
        const payload = await fetchStatus();
        const sourceIsActive = Boolean(payload?.online);

        if (sourceIsActive) {
          if (!streamAvailable) {
            setLiveState(true);
          } else if (!isPlaybackLive) {
            updateLiveBadge("live");
            updateToggleLabel();
          }
        } else if (streamAvailable && !isPlaybackLive) {
          setLiveState(false);
        }

        if (payload && (payload.title || payload.artist)) {
          if (titleEl && payload.title && payload.title !== currentTitle) {
            titleEl.textContent = payload.title;
            titleEl.classList.add("text-highlight");
            setTimeout(() => titleEl.classList.remove("text-highlight"), 600);
            currentTitle = payload.title;
          }

          if (artistEl && payload.artist && payload.artist !== currentArtist) {
            artistEl.textContent = payload.artist;
            artistEl.classList.add("text-highlight");
            setTimeout(() => artistEl.classList.remove("text-highlight"), 600);
            currentArtist = payload.artist;
          }
        }
      } catch (error) {
        console.error("No se pudo refrescar la canción", error);
      }
    }

    refreshNowPlaying();
    setInterval(refreshNowPlaying, 15000);
    setLiveState(false);

    player?.addEventListener("loadedmetadata", () => {
      updateDurationState();
      updateProgressUI();
    });
    player?.addEventListener("durationchange", updateDurationState);
    player?.addEventListener("timeupdate", () => updateProgressUI());

    progressInput?.addEventListener("input", () => {
      if (isPlaybackLive) return;
      updateProgressUI(true);
    });
    progressInput?.addEventListener("change", () => {
      if (!player || isPlaybackLive) return;
      const value = Number(progressInput.value);
      if (Number.isFinite(value)) {
        player.currentTime = value;
      }
    });

    if (volumeInput && player) {
      const initialVolume = Number(volumeInput.value);
      if (Number.isFinite(initialVolume)) {
        player.volume = initialVolume;
      }
      volumeInput.addEventListener("input", () => {
        const vol = Number(volumeInput.value);
        if (Number.isFinite(vol)) {
          player.volume = vol;
        }
      });
    }
  </script>

<style>
  .radio-shell {
    border: none;
    width: 100%;
    --player-accent: #b4ff00;
    --player-accent-light: #d8ff66;
    --player-accent-ink: #1a2500;
    --player-accent-shadow: rgba(180, 255, 0, 0.35);
  }

  .radio-content {
    position: relative;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-card));
    box-shadow: 12px 12px 0 rgba(var(--shadow-soft) / 0.16);
    padding: clamp(1.9rem, 3.2vw, 2.8rem);
    display: grid;
    gap: clamp(1.8rem, 3vw, 2.4rem);
    justify-items: center;
  }

  .radio-corners {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .radio-corners .corner {
    position: absolute;
    width: 18px;
    height: 18px;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-body));
  }

  .radio-corners .corner::after {
    content: "";
    position: absolute;
    inset: 4px;
    border: 1.5px solid rgb(var(--color-border-ink));
  }

  .corner--tl {
    top: -9px;
    left: -9px;
  }

  .corner--tr {
    top: -9px;
    right: -9px;
  }

  .corner--bl {
    bottom: -9px;
    left: -9px;
  }

  .corner--br {
    bottom: -9px;
    right: -9px;
  }

  .radio-headline {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
    align-items: center;
    text-align: center;
  }

  .headline-kicker {
    font-size: 0.75rem;
    letter-spacing: 0.35em;
    text-transform: uppercase;
    color: rgb(var(--color-text-muted));
  }

  /* Nuevo bloque compacto para el título/autor */
  .nowplaying {
    width: min(100%, 520px);
    justify-self: center;
  }
  .nowplaying .title-line {
    display: inline-flex;
    align-items: center;
    gap: 0.6rem;
    max-width: 100%;
    margin: 0.3rem auto 0;
    padding: 0.5rem 0.85rem;
    border: 1.5px solid rgb(var(--color-border-ink));
    border-radius: 14px;
    background: rgb(var(--color-bg-card));
    box-shadow: 5px 5px 0 rgba(var(--shadow-soft) / 0.14);
    color: rgb(var(--color-text-heading));
    font-size: 0.95rem;
    line-height: 1.25;
  }
  .nowplaying .np-dot {
    width: 10px;
    height: 10px;
    border-radius: 999px;
    background: var(--player-accent);
    box-shadow: 0 0 0 3px var(--player-accent-shadow);
    flex: 0 0 10px;
    align-self: center;
  }
  .nowplaying .np-text {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: normal;
    word-break: break-word;
    min-width: 0;
    max-width: 100%;
  }
  #song-title,
  #artist-name {
    display: inline;
    font-weight: 600;
  }
  .nowplaying .sep {
    margin: 0 0.35rem;
    color: rgb(var(--color-text-muted));
    font-weight: 400;
  }

  .eq-badge {
    display: inline-flex;
    align-items: flex-end;
    gap: 6px;
    border-radius: 16px;
    padding: 10px 14px;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-body));
    box-shadow: 5px 5px 0 rgba(var(--shadow-soft) / 0.16);
  }

  .eq-bar {
    width: 5px;
    height: 22px;
    border-radius: 2px;
    background: linear-gradient(180deg, var(--player-accent-light), var(--player-accent));
    animation: eqPulse 1.6s ease-in-out infinite;
    transform-origin: center bottom;
  }

  @keyframes eqPulse {
    0%,
    100% {
      transform: scaleY(0.35);
      opacity: 0.7;
    }
    40% {
      transform: scaleY(1.1);
      opacity: 1;
    }
    70% {
      transform: scaleY(0.5);
      opacity: 0.85;
    }
  }

  .player-surface {
    position: relative;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-elevated));
    padding: clamp(2rem, 4vw, 2.4rem) clamp(1.4rem, 4vw, 2rem) clamp(1.6rem, 4vw, 2rem);
    box-shadow: inset 0 0 0 1px rgba(var(--color-border-ink) / 0.08);
    width: min(100%, 520px);
  }

  .player-surface audio {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    width: 0;
    height: 0;
  }

  .player-foot {
    display: grid;
    gap: clamp(1.4rem, 2.5vw, 2rem);
    width: min(100%, 520px);
  }

  .timeline-row {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: center;
    gap: 1rem;
  }

  .timeline-track {
    position: relative;
    width: 100%;
    height: 0.7rem;
    border-radius: 999px;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-body));
    box-shadow: 3px 3px 0 rgba(var(--shadow-soft) / 0.12);
  }

  .progress-track {
    position: absolute;
    inset: 3px;
    border-radius: 999px;
    background: rgba(var(--color-border-ink) / 0.15);
    overflow: hidden;
    pointer-events: none;
  }

  .progress-fill {
    position: absolute;
    inset: 0;
    transform-origin: left center;
    transform: scaleX(0);
    background: linear-gradient(90deg, var(--player-accent-light), var(--player-accent));
    transition: transform 0.18s ease-out;
    pointer-events: none;
  }

  .progress-range {
    position: absolute;
    appearance: none;
    width: 100%;
    height: 100%;
    inset: 0;
    background: transparent;
    cursor: pointer;
    opacity: 0;
  }

  .progress-range:focus-visible {
    outline: none;
  }

  .progress-range.is-disabled {
    cursor: not-allowed;
  }

  .progress-range::-webkit-slider-thumb,
  .progress-range::-moz-range-thumb {
    appearance: none;
    width: 0;
    height: 0;
    border: none;
  }

  .time-chip {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 3.5rem;
    padding: 0.35rem 0.75rem;
    border-radius: 999px;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-body));
    color: rgb(var(--color-text-heading));
    letter-spacing: 0.1em;
    box-shadow: 3px 3px 0 rgba(var(--shadow-soft) / 0.16);
  }

  .live-indicator.live-active {
    background: rgb(232 82 74 / 0.9);
    color: rgb(255 248 235 / 1);
    box-shadow: 4px 4px 0 rgba(232, 82, 74, 0.28);
    gap: 0.35rem;
    padding-inline: 1rem;
  }

  .live-indicator.live-active::before {
    content: "";
    display: inline-block;
    width: 0.5rem;
    height: 0.5rem;
    border-radius: 999px;
    background: currentColor;
  }

  .live-indicator.live-offline {
    background: rgba(var(--color-border-ink) / 0.12);
    color: rgb(var(--color-text-muted));
    box-shadow: none;
  }

  .action-row {
    display: flex;
    flex-wrap: wrap;
    gap: 1.2rem;
    align-items: center;
    justify-content: center;
  }

  .player-control {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.65rem 1.5rem;
    border-radius: 999px;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-card));
    box-shadow: 6px 6px 0 rgba(var(--shadow-soft) / 0.16);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    width: max(170px, 48%);
    color: rgb(var(--color-text-heading));
  }

  .player-control:hover {
    transform: translateY(-2px);
  }

  .player-control:focus-visible {
    outline: 2px solid rgba(var(--color-border-ink) / 0.4);
    outline-offset: 4px;
  }

  .player-symbol {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2.2rem;
    height: 2.2rem;
    border-radius: 0.9rem;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-body));
    box-shadow: 4px 4px 0 rgba(var(--shadow-soft) / 0.16);
    transition: background 0.2s ease, border-color 0.2s ease;
  }

  .player-icon {
    display: inline-block;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 8px 0 8px 13px;
    border-color: transparent transparent transparent rgb(var(--color-border-ink));
    transition: border-width 0.2s ease, width 0.2s ease, height 0.2s ease, background 0.2s ease;
  }

  .player-control.is-playing .player-icon {
    border-width: 0;
    width: 13px;
    height: 13px;
    border-radius: 0.25rem;
    background: rgb(var(--color-border-ink));
  }

  .player-label {
    font-size: 0.75rem;
    letter-spacing: 0.26em;
    text-transform: uppercase;
    color: currentColor;
  }

  .player-control.is-live {
    background: var(--player-accent-light);
    box-shadow: 6px 6px 0 var(--player-accent-shadow);
    color: var(--player-accent-ink);
  }

  .player-control.is-live .player-symbol {
    background: rgb(255 253 245 / 0.9);
  }

  .player-control.is-live .player-icon {
    border-color: transparent transparent transparent var(--player-accent-ink);
  }

  .player-control.is-live.is-playing .player-icon {
    background: var(--player-accent-ink);
  }

  .player-control.is-offline {
    background: var(--player-accent);
    box-shadow: 6px 6px 0 var(--player-accent-shadow);
    color: var(--player-accent-ink);
  }

  .player-control.is-offline .player-symbol {
    background: rgb(var(--color-bg-card));
  }

  .player-control[data-live="off"]:hover,
  .player-control[data-live="on"]:hover {
    filter: brightness(1.02);
  }

  .volume-block {
    display: grid;
    gap: 0.4rem;
    min-width: 160px;
    width: max(200px, 48%);
  }

  .volume-kicker {
    font-size: 0.68rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: rgb(var(--color-text-muted));
  }

  .volume-control {
    display: flex;
    align-items: center;
    gap: 0.7rem;
    color: rgb(var(--color-text-heading));
  }

  .volume-control .fa-solid {
    font-size: 0.8rem;
  }

  .volume-range {
    width: 120px;
    appearance: none;
    height: 0.25rem;
    border-radius: 999px;
    background: rgba(var(--color-border-ink) / 0.18);
    cursor: pointer;
  }

  .volume-range:focus-visible {
    outline: none;
  }

  .volume-range::-webkit-slider-thumb {
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 999px;
    background: rgb(var(--color-bg-card));
    border: 1.5px solid rgb(var(--color-border-ink));
  }

  .volume-range::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 999px;
    background: rgb(var(--color-bg-card));
    border: 1.5px solid rgb(var(--color-border-ink));
  }

  .external-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.65rem 1.3rem;
    border-radius: 999px;
    border: 1.5px solid rgb(var(--color-border-ink));
    background: rgb(var(--color-bg-card));
    font-size: 0.8rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: rgb(var(--color-text-heading));
    box-shadow: 5px 5px 0 rgba(var(--shadow-soft) / 0.16);
  }

  .external-link:hover {
    transform: translateY(-2px);
  }

  @media (max-width: 640px) {
    .radio-content {
      padding: 1.6rem 1.35rem;
      gap: 1.4rem;
      justify-items: center;
    }

    .radio-headline {
      gap: 0.75rem;
    }

    .player-surface {
      padding: 1.7rem 1.2rem 1.4rem;
      width: 100%;
    }

    .timeline-row {
      grid-template-columns: 1fr;
      gap: 0.35rem;
    }

    .timeline-row .time-chip {
      justify-self: center;
    }

    .action-row {
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    .player-control,
    .external-link {
      width: min(100%, 240px);
      justify-content: center;
    }

    .volume-block {
      width: min(100%, 240px);
    }

    .volume-control {
      justify-content: space-between;
    }

    .live-indicator {
      align-self: center;
    }
  }
</style>
</client:load>
